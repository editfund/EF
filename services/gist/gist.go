// Copyright 2024 The Forgejo Authors. All rights reserved.
// SPDX-License-Identifier: GPL-3.0-or-later

package gist

import (
	"context"
	"fmt"
	"io"
	"os"
	"path/filepath"

	"code.gitea.io/gitea/models/db"
	gist_model "code.gitea.io/gitea/models/gist"
	repo_model "code.gitea.io/gitea/models/repo"
	user_model "code.gitea.io/gitea/models/user"
	"code.gitea.io/gitea/modules/git"
	"code.gitea.io/gitea/modules/setting"
	api "code.gitea.io/gitea/modules/structs"
	"code.gitea.io/gitea/modules/util"
)

const (
	GistBranch = "main"
)

// SetupGistHook creates the Gist Hook
func SetupGistHook(path string) error {
	err := os.Mkdir(filepath.Join(path, "hooks"), 0o750)
	if err != nil && !os.IsExist(err) {
		return err
	}

	hookContent := fmt.Sprintf("#!/usr/bin/env %s\n# AUTO GENERATED BY FORGEJO, DO NOT MODIFY\n%s hook --config=%s gist-pre-receive",
		setting.ScriptType, util.ShellEscape(setting.AppPath), util.ShellEscape(setting.CustomConf))

	err = os.WriteFile(filepath.Join(path, "hooks", "pre-receive"), []byte(hookContent), 0o777)
	if err != nil {
		return err
	}

	return nil
}

// CreateGist creates a Gist
func CreateGist(ctx context.Context, owner *user_model.User, name, description string, visibility gist_model.GistVisibility, files map[string]string) (*gist_model.Gist, error) {
	tempDir, err := os.MkdirTemp("", "")
	if err != nil {
		return nil, err
	}
	defer os.RemoveAll(tempDir)

	err = git.InitRepository(ctx, tempDir, git.InitRepositoryOptions{Bare: false, ObjectFormatName: git.Sha1ObjectFormat.Name(), Branch: GistBranch})
	if err != nil {
		return nil, err
	}

	nameList := make([]string, 0)
	for name, content := range files {
		if util.PathContainsDirectory(name) {
			return nil, fmt.Errorf("%s contains a directory", name)
		}

		err := os.WriteFile(filepath.Join(tempDir, name), []byte(content), 0o644)
		if err != nil {
			return nil, err
		}

		nameList = append(nameList, name)
	}

	err = git.AddChanges(tempDir, false, nameList...)
	if err != nil {
		return nil, err
	}

	err = git.CommitChanges(tempDir, git.CommitChangesOptions{
		Author:    &git.Signature{Name: owner.Name, Email: owner.Email},
		Committer: &git.Signature{Name: owner.Name, Email: owner.Email},
		Message:   "Init",
	})
	if err != nil {
		return nil, err
	}

	ctx, committer, err := db.TxContext(ctx)
	if err != nil {
		return nil, err
	}
	defer committer.Close()

	gist := new(gist_model.Gist)
	gist.Owner = owner
	gist.OwnerID = owner.ID
	gist.Name = name
	gist.Description = description
	gist.Visibility = visibility

	err = gist_model.Create(ctx, gist)
	if err != nil {
		return nil, err
	}

	err = git.InitRepository(ctx, gist.GetRepoPath(), git.InitRepositoryOptions{Bare: true, Branch: GistBranch, ObjectFormatName: git.Sha1ObjectFormat.Name()})
	if err != nil {
		return nil, err
	}

	cmd := git.NewCommand(ctx, "push", "--set-upstream")
	cmd.AddDynamicArguments(gist.GetRepoPath())
	cmd.AddDynamicArguments(GistBranch)
	_, _, err = cmd.RunStdString(&git.RunOpts{Dir: tempDir})
	if err != nil {
		os.RemoveAll(gist.GetRepoPath())
		return nil, err
	}

	err = SetupGistHook(gist.GetRepoPath())
	if err != nil {
		os.RemoveAll(gist.GetRepoPath())
		return nil, err
	}

	err = committer.Commit()
	if err != nil {
		return nil, err
	}

	return gist, nil
}

// GetFiles returns teh files of a Gist
func GetFiles(ctx context.Context, gist *gist_model.Gist) (GistFiles, error) {
	repo, err := git.OpenRepository(ctx, gist.GetRepoPath())
	if err != nil {
		return nil, err
	}
	defer repo.Close()

	branch, err := repo.GetBranch(GistBranch)
	if err != nil {
		return nil, err
	}

	commit, err := branch.GetCommit()
	if err != nil {
		return nil, err
	}

	entries, err := commit.ListEntries()
	if err != nil {
		return nil, err
	}

	files := make([]*api.GistFile, len(entries))

	for pos, currentEntry := range entries {
		reader, err := currentEntry.Blob().DataAsync()
		if err != nil {
			return nil, err
		}
		defer reader.Close()

		content, err := io.ReadAll(reader)
		if err != nil {
			return nil, err
		}

		currentFile := new(api.GistFile)
		currentFile.Name = currentEntry.Name()
		currentFile.Content = string(content)

		files[pos] = currentFile
	}

	return files, nil
}

// GetBlob returns a blob of a Gist file
func GetBlob(ctx context.Context, gist *gist_model.Gist, filename string) (*git.Blob, error) {
	repo, err := git.OpenRepository(ctx, gist.GetRepoPath())
	if err != nil {
		return nil, err
	}
	defer repo.Close()

	branch, err := repo.GetBranch(GistBranch)
	if err != nil {
		return nil, err
	}

	commit, err := branch.GetCommit()
	if err != nil {
		return nil, err
	}

	return commit.GetBlobByPath(filename)
}

// UpdateFiles replaces the files of a Gist
func UpdateFiles(ctx context.Context, gist *gist_model.Gist, doer *user_model.User, files GistFiles) error {
	for _, currentFile := range files {
		if util.PathContainsDirectory(currentFile.Name) {
			return fmt.Errorf("%s contains a directory", currentFile.Name)
		}
	}

	tempDir, err := os.MkdirTemp("", "")
	if err != nil {
		return err
	}
	defer os.RemoveAll(tempDir)

	oldFiles, err := GetFiles(ctx, gist)
	if err != nil {
		return err
	}

	err = git.Clone(ctx, gist.GetRepoPath(), tempDir, git.CloneRepoOptions{})
	if err != nil {
		return err
	}

	// Delete files that are no longer in the Gist
	missingFiles := make([]string, 0)
	for _, currentOldFile := range oldFiles {
		if !files.Contains(currentOldFile.Name) {
			missingFiles = append(missingFiles, currentOldFile.Name)
		}
	}

	if len(missingFiles) > 0 {
		err = git.RemoveFiles(tempDir, missingFiles...)
		if err != nil {
			return err
		}
	}

	changedFiles := make([]string, 0)
	for _, currentFile := range files {
		err := os.WriteFile(filepath.Join(tempDir, currentFile.Name), []byte(currentFile.Content), 0o644)
		if err != nil {
			return err
		}

		changedFiles = append(changedFiles, currentFile.Name)
	}

	err = git.AddChanges(tempDir, false, changedFiles...)
	if err != nil {
		return err
	}

	err = git.CommitChanges(tempDir, git.CommitChangesOptions{
		Author:    &git.Signature{Name: doer.Name, Email: doer.Email},
		Committer: &git.Signature{Name: doer.Name, Email: doer.Email},
		Message:   "Update",
	})
	if err != nil {
		return err
	}

	err = git.Push(ctx, tempDir, git.PushOptions{
		Remote: gist.GetRepoPath(),
	})
	if err != nil {
		return err
	}

	return nil
}

// DeleteGist delets a Gist
func DeleteGist(ctx context.Context, gist *gist_model.Gist) error {
	ctx, committer, err := db.TxContext(ctx)
	if err != nil {
		return err
	}
	defer committer.Close()

	_, err = db.GetEngine(ctx).Exec("DELETE FROM gist WHERE id = ?", gist.ID)
	if err != nil {
		return err
	}

	err = os.RemoveAll(gist.GetRepoPath())
	if err != nil {
		return err
	}

	return committer.Commit()
}

func DeleteOwnerGists(ctx context.Context, owner *user_model.User) error {
	for {
		gistList := make(gist_model.GistList, 0)

		err := db.GetEngine(ctx).Where("owner_id = ?", owner.ID).Limit(repo_model.RepositoryListDefaultPageSize).Find(&gistList)
		if err != nil {
			return err
		}

		if len(gistList) == 0 {
			return nil
		}

		for _, gist := range gistList {
			err = DeleteGist(ctx, gist)
			if err != nil {
				return err
			}
		}
	}
}
